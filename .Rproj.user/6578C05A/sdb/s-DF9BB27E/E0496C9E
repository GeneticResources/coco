{
    "collab_server" : "",
    "contents" : "##' Stepwise conditional wrapper\n##'\n##' Generate conditional signals from a specific set of SNPs\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title conditional_from_ids\n##' @param data_set data.frame. Contains the relevant\n##' @param ld_matrix\n\nconditional_from_ids = function(rsids, data_set, ld_matrix, indexes){\n  hwe_diag = res_preparation$hwe_diag\n  data_set = res_preparation$data_set\n  hwe_diag_outside = res_preparation$hwe_diag_outside\n  ld_matrix = res_preparation$ld_matrix\n  var_y = res_preparation$var_y\n  if(!missing(rsids)){\n    rsid_idx = which(data_set$rsid %in% indexes)\n  } else if(!missing(indexes)){\n    rsid_idx = indexes\n  }else{\n    stop(\"Neither indexes of rsids specified\")\n  }\n  if(length(rsid_idx) == 0){\n    stop(\"No rsids or indexes to conditional on were found\")\n  }\n  res_step= get_joint_betas(idx_joint = idx_cond, ld_matrix = ld_matrix,\n                  hwe_diag = hwe_diag, hwe_diag_outside = hwe_diag_outside,data_set = data_set,\n                  colinear_threshold = 0.9,var_y=var_y)\n  res_step = list(res_step=res_step, main_hit=as.character(data_set$rsid[idx_joint[hit]]),\n       conditional_on=c(as.character(data_set$rsid[rsid_idx])))\n  return(res_step)\n}\n\n##'\n##' Generate conditional signals from a conditional dataset.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title stepwise_conditional\n##' @param data_set data.frame. Contains the relevant\n##' @param ld_matrix\n##' @param p_value_threshold.\n##' @param ld_noise\n##'\n##'\nstepwise_conditional_wrapper = function(data_set ,ld_matrix,p_value_threshold = 1e-3,var_y = 1.6421, ld_noise=0){\n  res_preparation_x = prep_dataset_common(data_set = data_set,ld_matrix= ld_matrix,ld_noise=ld_noise, var_y = var_y)\n  stepwise_results_x = stepwise_conditional_run(res_preparation = res_preparation_x,p_value_threshold = p_value_threshold)\n  all_but_one_df_x = all_but_one(res_preparation=res_preparation_x,stepwise_results = stepwise_results_x)\n  return (all_but_one_df_x)\n}\n\n##' Prepare dataset common\n##'\n##' Common utilities for checking and parsing a dataset\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title stepwise_conditional\n##' @param data_set\n##'\nprep_dataset_common = function(data_set,ld_matrix,var_y, ld_noise=0){\n    if(missing(data_set)){\n      stop(\"Must specify a data_set argument\")\n    }\n    if(missing(ld_matrix)){\n      stop(\"Must specify an ld_matrix argument on the command-line\")\n    }\n    if(missing(var_y)){\n      stop(\"Must specify vary_y on the command line\")\n    }\n    message(\"Preparing the dataset for a  conditional analysis\")\n\n    pos = which(grepl(\"^pos$|^bp$|^bp_hg19$|^position$|^chrom_start$\", names(data_set),  ignore.case = T))\n    if(length(pos) == 0){\n      stop(\"Position column not found\")\n    }\n    colnames(data_set)[pos] = \"pos\"\n    beta = which(grepl(\"^beta$|^effect$|^logor$\", names(data_set),  ignore.case = T))[1]\n    if(length(beta) == 0){\n      beta =  which(grepl(\"^or$\", names(data_set),  ignore.case = T))[1]\n      if(length(beta) == 0){\n        stop(\"BETA/OR column not found\")\n      }\n      data_set[beta,] = log(data_set[beta,])\n    }\n    colnames(data_set)[beta] = \"beta\"\n    af = which(grepl(\"^F$|freq|FRQ|MAF\", names(data_set),  ignore.case = T))[1]\n    if(length(af) == 0){\n      stop(\"AF column not found\")\n    }# sometimes have 2 (one for each allele), doesn't matter whcih you take for our applications (fGWAS and coloc)\n    colnames(data_set)[af] = \"af\"\n\n    se = which(grepl(\"^se$|^StdErr$|BMIadjMainSE\", names(data_set),  ignore.case = T))\n    if(length(se) == 0){\n      stop(\"SE column not found\")\n    }\n    colnames(data_set)[se] = \"se\"\n    n = which(grepl(\"^N$|^TotalSampleSize$|^SAMPLE_SIZE$\", names(data_set),  ignore.case = T))\n    if(length(n) == 0){\n      stop(\"n column not found\")\n    }\n    colnames(data_set)[n] = \"n\"\n\n    info = which(grepl(\"INFO|RSQ\", names(data_set),  ignore.case = T))\n    if(length(info) == 0){\n      message(\"Info column not found assuming HWE genotypic variance\")\n      data_set$info = 1\n    }\n    colnames(data_set)[info] = \"info\"\n\n    z = which(grepl(\"^Z$|zscore\", names(data_set),  ignore.case = T))\n    if(length(z) ==0){\n      data_set$z = data_set$b/data_set$se\n    }\n    colnames(data_set)[z] = \"z\"\n    #order the dataset on the position column\n    data_set = data_set[order(data_set$pos),]\n\n    hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$n)\n\n    data_set$neff = (var_y * data_set$n) / (hwe_diag *data_set$se^2)  - (data_set$b^2) / (data_set$se^2) +1\n\n    hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$neff)\n    hwe_diag_outside =  (2*data_set$af * ( 1- data_set$af))\n\n    if(ld_noise != 0){\n      ld_matrix[cbind(1:nrow(ld_matrix),1:nrow(ld_matrix))]  = ld_matrix[cbind(1:nrow(ld_matrix),1:nrow(ld_matrix))] + ld_noise\n    }\n    return(list(data_set=data_set,ld_matrix=ld_matrix,var_y=var_y,hwe_diag=hwe_diag,hwe_diag_outside=hwe_diag_outside))\n}\n\n\n##' Stepwise estimation.\n##'\n##' Generate conditional signals from a conditional dataset.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title stepwise_conditional\n##' @param data_set\n##' @param p_value_threshold.\n##'\n##'\nstepwise_conditional_run = function(res_preparation,p_value_threshold=0.0001,colinear_threshold=0.9){\n  #extract variance from the dataset\n  #hwe_diag = (2*freq_af$af * ( 1- data_set$af) * data_set$n)\n  # Extract the effective sample size for a SNP.\n  hwe_diag = res_preparation$hwe_diag\n  data_set = res_preparation$data_set\n  var_y = res_preparation$var_y\n  hwe_diag_outside = res_preparation$hwe_diag_outside\n  ld_matrix = res_preparation$ld_matrix\n  var_y = res_preparation$var_y\n  #print(nrow(ld_matrix))\n  idx_top_tmp = c(which(max(abs(data_set$z)) == abs(data_set$z)))\n  conditional_df = data_set[idx_top_tmp,]\n#  print(idx_top_tmp)\n  message(paste(\"Top SNP for region = \", conditional_df$rsid, \", with Z-score \", conditional_df$z), \" index \",idx_top_tmp)\n  current_best_p = 2 * pnorm(abs(conditional_df$z), lower.tail = F)\n  idx_cond = c()\n  message(paste(\"Conditioning ...\"))\n  out_all_buts = data.frame(rsid=conditional_df$rsid, beta_old=conditional_df$b, beta_new=NA\n                            ,se_old=conditional_df$se, se_new =NA,Znew=NA,p=current_best_p)\n  while(current_best_p < p_value_threshold){\n    idx_cond = c(idx_cond, idx_top_tmp)\n    res_step = data.frame(rsid=data_set$rsid,beta_old=data_set$b, beta_new=rep(NA,nrow(ld_matrix)),\n                          se_old=data_set$se, se_new=rep(NA,nrow(ld_matrix)))\n\n    if(length(idx_cond) == nrow(ld_matrix)){\n      message(\"All SNPs in joint model\")\n      break\n    }\n    res_step= get_joint_betas(idx_joint = idx_cond, ld_matrix = ld_matrix,\n                              hwe_diag = hwe_diag, hwe_diag_outside = hwe_diag_outside,data_set = data_set,\n                              all_but_one = F,colinear_threshold = 0.9, var_y=var_y)\n    res_step$Znew = res_step$beta_new/res_step$se_new\n    idx_top_tmp = which(max(abs(res_step$Znew),na.rm=T) == abs(res_step$Znew))\n    best_cond_row = res_step[idx_top_tmp,]\n    current_best_p = 2 * pnorm(abs(best_cond_row$Znew), lower.tail = F)\n    message(paste(\"Best SNP is = \", best_cond_row$rsid, \"with P-value \", current_best_p, \" Index = \", idx_top_tmp))\n    message(paste(\"Beta = \", best_cond_row$beta_new, \" Z = \",best_cond_row$Znew))\n    if(current_best_p < p_value_threshold){\n      best_cond_row$p = current_best_p\n      out_all_buts = rbind(out_all_buts,best_cond_row)\n    }\n  }\n  return(out_all_buts)\n}\n\n##' Step conditional\n##'\n##' Run a joint step of the analysis.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title step_conditional\n##' @param betas vector of betas that will be adjusted in the matrix operations.\n##' @param ld_matrix LD matrix for the subset of the region.\n##' @param neff effective sample size for each SNP in the dataset\n##' @param var_y variance of of the phenotype\n##' @param hwe_diag_outside Diagonal matrix containing the genotypic variance\n##' @param hwe_diag Diagonal matrix containing the genotypic variance *n\n##' @return Joint betas and standard errors.\n\nstep_conditional = function(betas, ld_matrix,neffs,var_y, hwe_diag_outside,hwe_diag){\n  inside =  ld_matrix\n  n_betas = length(betas)\n  outside = sqrt(diag(hwe_diag_outside)) %*% inside %*% sqrt(diag(hwe_diag_outside))\n  for(j in 1:ncol(outside)){\n    for(k in (j):ncol(outside)){\n      if(k > ncol(outside)){\n        break\n      }\n      outside[j,k] = min(neffs[c(j,k)]) *  outside[j,k]\n      if(k!=j){\n        outside[k,j] = min(neffs[c(j,k)]) * outside[k,j]\n      }\n    }\n  }\n  #print( sqrt(diag(hwe_diag)) %*% inside %*% sqrt(diag(hwe_diag)))\n  print(outside)\n  beta_inv = chol2inv(chol(outside))\n  #print(betas)\n  new_betas = beta_inv %*% diag(hwe_diag) %*% betas\n  #print(beta_inv)\n  # We only really care about the results from the first SNP\n  #because that's our SNP we are adding to the model\n  neff_var_y = neffs[1] * var_y\n  vars = (neff_var_y - t(betas) %*%  diag(hwe_diag) %*% ((betas))) / (neffs[1] - length(n_betas))\n  #print(vars)\n  ses = sqrt(diag(vars[1] * beta_inv))\n  #print(ses)\n  return(c(new_betas[1,1],ses[1]))\n}\n\n\nget_joint_betas = function(idx_joint,data_set,ld_matrix, hwe_diag,hwe_diag_outside,var_y,colinear_threshold=.9){\n  res_step = data.frame(rsid=data_set$rsid,beta_old=data_set$b, beta_new=rep(NA,nrow(ld_matrix)),\n                      se_old=data_set$se, se_new=rep(NA,nrow(ld_matrix)))\n  for(j in 1:nrow(data_set)){\n      if(j %in% idx_joint){\n        message(\"Skipping SNP as already being conditioned on\")\n        next\n      }\n    of_interest = c(j, idx_joint)\n    betas = data_set$b[of_interest]\n    tmp_ld_matrix = ld_matrix[of_interest,of_interest]\n    neffs = data_set$neff[of_interest]\n    if(any(abs(tmp_ld_matrix[1,2:ncol(tmp_ld_matrix)]) > colinear_threshold)){\n      # message(\"Skipping SNP as co-linear with top_snps.\")\n      next\n    }\n    hwe_diag_outside_tmp = hwe_diag_outside[of_interest]\n    hwe_diag_tmp = hwe_diag[of_interest]\n    cond_results = step_conditional(betas, tmp_ld_matrix, neffs,var_y, hwe_diag_outside_tmp,hwe_diag_tmp)\n    res_step$beta_new[j]= cond_results[1]\n    res_step$se_new[j]= cond_results[2]\n  }\n  return(res_step)\n}\n\n##' All but one analysis\n##'\n##' Run the all but one analysis of the dataset.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title all_but_one\n##' @param data_set input file format\n##' @param ld_matrix LD matrix for the subset of the region.\n##' @param stepwise_results - results from a stepwise analysis.\n##' @return all_but_ones  betas and standard error for the entire region.\n##'\nall_but_one = function(res_preparation, stepwise_results,p_value_threshold=1e-6,colinear_threshold=0.9){\n  #extract variance from the dataset\n  hwe_diag = res_preparation$hwe_diag\n  data_set = res_preparation$data_set\n  var_y = res_preparation$var_y\n  hwe_diag_outside = res_preparation$hwe_diag_outside\n  ld_matrix = res_preparation$ld_matrix\n  idx_joint = which(data_set$rsid %in% stepwise_results$rsid)\n\n  if(length(idx_joint) == 0){\n    stop(\"No SNPs to perform an all but one conditional analysis on\")\n  }\n  if(length(idx_joint) == 1){\n   combinations=matrix(c(1))\n  }else{\n    combinations = combn(length(idx_joint),length(idx_joint) - 1)\n  }\n  message(paste(\"Runnnig the all but one conditional analysis for \",length(idx_joint),\" snps\"))\n  #message(paste(\"SNPs in model ... \"))\n  #message(as.character(data_set$rsid[idx_joint]), sep=\"\\n\")\n  all_but_one_res = list()\n  for(i in 1:ncol(combinations)){\n  #  idx_conditional = c(tmp_model_idx)\n    tmp_model_idx = idx_joint[combinations[,i]]\n    res_step= get_joint_betas(idx_joint = tmp_model_idx, ld_matrix = ld_matrix,\n                              hwe_diag = hwe_diag, hwe_diag_outside = hwe_diag_outside,data_set = data_set,\n                              colinear_threshold = 0.9,var_y = var_y)\n    hit = which(!(1:length(idx_joint) %in% combinations[,i]))\n    all_but_one_res[[i]] = list(res_step=res_step, main_hit=as.character(data_set$rsid[idx_joint[hit]]),\n                                             conditional_on=c(as.character(data_set$rsid[idx_joint[combinations[,i]]])))\n  }\n  return(all_but_one_res)\n}\n",
    "created" : 1470175381766.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3732579728",
    "id" : "E0496C9E",
    "lastKnownWriteTime" : 1470370757,
    "last_content_update" : 1470370757365,
    "path" : "~/Sinai/corrcond/R/corrcond.R",
    "project_path" : "R/corrcond.R",
    "properties" : {
        "marks" : "<:308,0\n>:308,0",
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
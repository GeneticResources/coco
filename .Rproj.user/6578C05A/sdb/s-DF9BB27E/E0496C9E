{
    "collab_server" : "",
    "contents" : "##' Stepwise estimation.\n##'\n##' Generate conditional signals from a conditional dataset.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title stepwise_conditional\n##' @param data_set\n##' @param p_value_threshold.\n##'\n##'\n\nstepwise_conditional_run = function(data_set,ld_matrix ,p_value_threshold=0.00001,colinear_threshold=0.9,var_y = 1.6421){\n  #extract variance from the dataset\n  #hwe_diag = (2*freq_af$af * ( 1- data_set$af) * data_set$n)\n  # Extract the effective sample size for a SNP.\n  # Generate hwe_diagonal\n\n  hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$n)\n  sigma_m = ((var_y * data_set$n) - hwe_diag * data_set$b^2) / (data_set$n - 1 )\n  sigma_m = sigma_m / hwe_diag\n  data_set$neff = (var_y * data_set$n) / (hwe_diag *sigma_m)  - (data_set$b^2) / (sigma_m) +1\n2\n  # Remove HWE diagonal\n  hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$neff)\n#  hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$neff * data_set$info)  ## ??\n  # Get hwe D matrix\n\n  # Get hwe D matri x without sample size, needed to generate B matrix.\n  hwe_diag_outside=  (2*data_set$af * ( 1- data_set$af))\n  message(\"Running a stepwise conditional analysis\")\n  if (!(\"Z\" %in% names(data_set))){\n    data_set$Z = data_set$b / data_set$se\n  }\n#  print(names(data_set))\n  # ids of the conditional hits.\n\n  idx_top_tmp = c(which(max(abs(data_set$Z)) == abs(data_set$Z)))\n  conditional_df = data_set[idx_top_tmp,]\n#  print(idx_top_tmp)\n  message(paste(\"Top SNP for region = \", conditional_df$rsid, \", with Z-score \", conditional_df$Z))\n  current_best_p = 2 * pnorm(abs(conditional_df$Z), lower.tail = F)\n  idx_cond = c()\n  message(paste(\"Conditioning ...\"))\n  out_all_buts = data.frame(rsid=conditional_df$rsid, beta_old=conditional_df$b, beta_new=NA\n                            ,se_old=conditional_df$se, se_new =NA,Znew=NA,p=current_best_p)\n  while(current_best_p < p_value_threshold){\n    idx_cond = c(idx_cond, idx_top_tmp)\n    res_step = data.frame(rsid=data_set$rsid,beta_old=data_set$b, beta_new=rep(NA,nrow(ld_matrix)), se_old=data_set$se, se_new=rep(NA,nrow(ld_matrix)))\n\n    if(length(idx_cond) == nrow(ld_matrix)){\n      message(\"All SNPs in joint model\")\n      break\n    }\n2\n    for(i in 1:nrow(ld_matrix)){\n        if(i %in% idx_cond){\n          message(\"Skipping SNP as already being conditioned on\")\n          next\n        }\n        of_interest = c(i, idx_cond)\n        betas = data_set$b[of_interest]\n        tmp_ld_matrix = ld_matrix[of_interest,of_interest]\n        neffs = data_set$neff[of_interest]\n        if(any(abs(tmp_ld_matrix[1,2:ncol(tmp_ld_matrix)]) > colinear_threshold)){\n          #message(\"Skipping SNP as co-linear with top_snps.\")\n          next\n        }\n\n        hwe_diag_outside_tmp = hwe_diag_outside[of_interest]\n        hwe_diag_tmp = hwe_diag[of_interest]\n        cond_results = step_conditional(betas, tmp_ld_matrix, neffs,var_y, hwe_diag_outside_tmp,hwe_diag_tmp)\n        res_step$beta_new[i]= cond_results[1]\n        res_step$se_new[i]= cond_results[2]\n    }\n    res_step$Znew = res_step$beta_new/res_step$se_new\n    idx_top_tmp = which(max(abs(res_step$Znew),na.rm=T) == abs(res_step$Znew))\n    best_cond_row = res_step[idx_top_tmp,]\n    current_best_p = 2 * pnorm(abs(best_cond_row$Znew), lower.tail = F)\n    message(paste(\"Best SNP is = \", best_cond_row$rsid, \"with P-value \", current_best_p, \" Index = \", idx_top_tmp))\n    message(paste(\"Beta = \", best_cond_row$beta_new, \" Z = \",best_cond_row$Znew))\n    if(current_best_p < p_value_threshold){\n      best_cond_row$p = current_best_p\n      out_all_buts = rbind(out_all_buts,best_cond_row)\n    }\n\n  }\n  return(out_all_buts)\n}\n\n##' Step conditional\n##'\n##' Run a joint step of the analysis.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title step_conditional\n##' @param betas vector of betas that will be adjusted in the matrix operations.\n##' @param ld_matrix LD matrix for the subset of the region.\n##' @param neff effective sample size for each SNP in the dataset\n##' @param var_y variance of of the phenotype\n##' @param hwe_diag_outside Diagonal matrix containing the genotypic variance\n##' @param hwe_diag Diagonal matrix containing the genotypic variance *n\n##' @return Joint betas and standard errors.\n\nstep_conditional = function(betas, ld_matrix,neffs,var_y, hwe_diag_outside,hwe_diag){\n  inside =  ld_matrix\n  n_betas = length(betas)\n  outside = sqrt(diag(hwe_diag_outside)) %*% inside %*% sqrt(diag(hwe_diag_outside))\n  for(j in 1:ncol(outside)){\n    for(k in (j):ncol(outside)){\n      if(k > ncol(outside)){\n        break\n      }\n      outside[j,k] = min(neffs[c(j,k)]) *  outside[j,k]\n      if(k!=j){\n        outside[k,j] = min(neffs[c(j,k)]) * outside[k,j]\n      }\n    }\n  }\n # print(\"Outside\")\n#print(outside)\n#print( sqrt(diag(hwe_diag)) %*% inside %*% sqrt(diag(hwe_diag)))\n  beta_inv = chol2inv(chol(outside))\n  new_betas = beta_inv %*% diag(hwe_diag) %*% betas\n  #print(beta_inv)\n  # We only really care about the results from the first SNP\n  #because that's our SNP we are adding to the model\n  neff_var_y = neffs[1] * var_y\n  vars = (neff_var_y - t(new_betas) %*%  diag(hwe_diag) %*% ((betas))) / (neffs[1] - length(n_betas))\n  #print(vars)\n  ses = sqrt(diag(vars[1] * beta_inv))\n  return(c(new_betas[1,1],ses[1]))\n}\n\n\n##' All but one analysis\n##'\n##' Run the all but one analysis of the dataset.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title all_but_one\n##' @param data_set input file format\n##' @param ld_matrix LD matrix for the subset of the region.\n##' @param stepwise_results - results from a stepwise analysis.\n##' @return all_but_ones  betas and standard error for the entire region.\n##'\nall_but_one = function(data_set,ld_matrix, stepwise_results,p_value_threshold=0.00001,colinear_threshold=0.9,var_y = 1.6421){\n  #extract variance from the dataset\n  #hwe_diag = (2*freq_af$af * ( 1- data_set$af) * data_set$n)\n  # Extract the effective sample size for a SNP.\n  hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$n)\n  sigma_m = ((var_y * data_set$n) - hwe_diag * data_set$b^2) / (data_set$n - 1 )\n  sigma_m = sigma_m / hwe_diag\n  data_set$neff = (var_y * data_set$n) / (hwe_diag *sigma_m)  - (data_set$b^2) / (sigma_m) +1\n  #print(data_set$neff)\n  #print(hwe_diag)\n  # Remove HWE diagonal\n  hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$neff)\n  # Get hwe D matrix\n\n  # Get hwe D matri x without sample size, needed to generate B matrix.\n  hwe_diag_outside=  (2*data_set$af * ( 1- data_set$af))\n  message(\"Running a all but one conditional analysis\")\n  if (!(\"Z\" %in% names(data_set))){\n    data_set$Z = data_set$b / data_set$se\n  }\n  idx_joint = which(data_set$rsid %in% stepwise_results$rsid)\n  if(length(idx_joint) == 0){\n    stop(\"No SNPs to perform an all but one conditional analysis on\")\n  }\n  if(length(idx_joint) == 1){\n   combinations=matrix(c(idx_joint))\n  }else{\n    combinations = combn(length(idx_joint),length(idx_joint) - 1)\n  }\n\n  message(paste(\"Runnnig a all but one analysis for \",length(idx_joint),\" snps\"))\n  all_but_one_res = list()\n  for(i in 1:ncol(combinations)){\n  #  idx_conditional = c(tmp_model_idx)\n    tmp_model_idx = combinations[,i]\n    res_step = data.frame(rsid=data_set$rsid,beta_old=data_set$b, beta_new=rep(NA,nrow(ld_matrix)), se_old=data_set$se, se_new=rep(NA,nrow(ld_matrix)))\n    for(j in 1:nrow(data_set)){\n\n      if(j %in% tmp_model_idx){\n          res_step$beta_new[j] = res_step$beta_old[j]\n          res_step$se_new[j] = res_step$se_old[j]\n        }\n        of_interest = c(j, tmp_model_idx)\n        betas = data_set$b[of_interest]\n        tmp_ld_matrix = ld_matrix[of_interest,of_interest]\n        neffs = data_set$neff[of_interest]\n        if(any(abs(tmp_ld_matrix[1,2:ncol(tmp_ld_matrix)]) > colinear_threshold)){\n          message(\"Skipping SNP as co-linear with top_snps.\")\n          next\n        }\n        hwe_diag_outside_tmp = hwe_diag_outside[of_interest]\n        hwe_diag_tmp = hwe_diag[of_interest]\n        cond_results = step_conditional(betas, tmp_ld_matrix, neffs,var_y, hwe_diag_outside_tmp,hwe_diag_tmp)\n        res_step$beta_new[j]= cond_results[1]\n        res_step$se_new[j]= cond_results[2]\n    }\n    all_but_one_res = c(all_but_one_res,list(res_step))\n  }\n  return(all_but_one_res)\n}\n",
    "created" : 1470175381766.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1443439624",
    "id" : "E0496C9E",
    "lastKnownWriteTime" : 1470274029,
    "last_content_update" : 1470274088497,
    "path" : "~/Sinai/corrcond/R/corrcond.R",
    "project_path" : "R/corrcond.R",
    "properties" : {
        "marks" : "<:18,0\n>:18,0",
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
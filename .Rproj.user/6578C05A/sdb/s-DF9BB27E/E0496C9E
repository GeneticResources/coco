{
    "collab_server" : "",
    "contents" : "##' Stepwise conditional wrapper\n##'\n##' Generate conditional signals from a conditional dataset.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title stepwise_conditional\n##' @param data_set\n##' @param ld_matrix\n##' @param p_value_threshold.\n##' @param ld_noise\n##'\n##'\nstepwise_conditional_wrapper = function(data_set ,ld_matrix,p_value_threshold = 1e-3,var_y = 1.6421, ld_noise=0.1){\n\n}\n\n##' Prepare dataset common\n##'\n##' Common utilities for checking and parsing a dataset\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title stepwise_conditional\n##' @param data_set\n##'\nprep_dataset_common = function(data_set,ld_matrix, ld_noise=0){\n\n  message(\"Preparing the dataset for a  conditional analysis\")\n  if(ncol(ld_matrix) != nrow(data_set)){\n    stop(\"LD matrix is no the same size as the dataset cannot continue\")\n  }\n  if( !(\"b\" %in% names(data_set) )){\n    stop(\"Input data.frame must contain a rsid column\")\n  }\n  if( !(\"rsid\" %in% names(data_set) )){\n    stop(\"Input data.frame must contain a rsid column\")\n  }\n  if( !(\"n\" %in% names(data_set) )){\n    stop(\"Input data.frame must contain a n column, if n is unknown for each snp just set to sample size of study\")\n  }\n  if( !(\"se\" %in% names(data_set) )){\n    stop(\"Input data.frame must contain a se column\")\n  }\n  if( !(\"af\" %in% names(data_set) )){\n    stop(\"Input data.frame must contain a af column\")\n  }\n\n  hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$n)\n  sigma_m = ((var_y * data_set$n) - hwe_diag * data_set$b^2) / (data_set$n - 1 ) / (hwe_diag)\n  #hwe_diag * sigma_m ()\n  data_set$neff = (var_y * data_set$n) / (hwe_diag *data_set$se^2)  - (data_set$b^2) / (data_set$se^2) +1\n  # Remove HWE diagonal\n  #  print(data_set$neff)\n  hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$neff)\n\n  #  hwe_diag =  (2*data_set$af * ( 1- data_set$af) * data_set$neff * data_set$info)  ## ??\n  # Get hwe D matrix\n\n  # Get hwe D matri x without sample size, needed to generate B matrix.\n  hwe_diag_outside=  (2*data_set$af * ( 1- data_set$af))\n  if( !(\"Z\" %in% names(data_set))){\n    data_set$Z = data_set$b / data_set$se\n  }\n  #  print(names(data_set))\n  # ids of the conditional hits.\n  if(ld_noise != 0){\n    ld_matrix[cbind(1:nrow(ld_matrix),1:nrow(ld_matrix))]  = ld_matrix[cbind(1:nrow(ld_matrix),1:nrow(ld_matrix))] + ld_noise\n  }\n  return(list(hwe_diag=hwe_diag,hwe_diag_outside=hwe_diag_outside, data_set=data_set,ld_matrix=ld_matrix))\n}\n\n\n##' Stepwise estimation.\n##'\n##' Generate conditional signals from a conditional dataset.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title stepwise_conditional\n##' @param data_set\n##' @param p_value_threshold.\n##'\n##'\nstepwise_conditional_run = function(res_preparation,p_value_threshold=0.00001,colinear_threshold=0.9,var_y = 1.6421){\n  #extract variance from the dataset\n  #hwe_diag = (2*freq_af$af * ( 1- data_set$af) * data_set$n)\n  # Extract the effective sample size for a SNP.\n  hwe_diag = res_preparation$hwe_diag\n  data_set = res_preparation$data_set\n  hwe_diag_outside = res_preparation$hwe_diag_outside\n  ld_matrix = res_preparation$ld_matrix\n  #print(nrow(ld_matrix))\n  idx_top_tmp = c(which(max(abs(data_set$Z)) == abs(data_set$Z)))\n  conditional_df = data_set[idx_top_tmp,]\n#  print(idx_top_tmp)\n  message(paste(\"Top SNP for region = \", conditional_df$rsid, \", with Z-score \", conditional_df$Z), \" index \",idx_top_tmp)\n  current_best_p = 2 * pnorm(abs(conditional_df$Z), lower.tail = F)\n  idx_cond = c()\n  message(paste(\"Conditioning ...\"))\n  out_all_buts = data.frame(rsid=conditional_df$rsid, beta_old=conditional_df$b, beta_new=NA\n                            ,se_old=conditional_df$se, se_new =NA,Znew=NA,p=current_best_p)\n  while(current_best_p < p_value_threshold){\n    idx_cond = c(idx_cond, idx_top_tmp)\n    res_step = data.frame(rsid=data_set$rsid,beta_old=data_set$b, beta_new=rep(NA,nrow(ld_matrix)),\n                          se_old=data_set$se, se_new=rep(NA,nrow(ld_matrix)))\n\n    if(length(idx_cond) == nrow(ld_matrix)){\n      message(\"All SNPs in joint model\")\n      break\n    }\n    res_step= get_joint_betas(idx_joint = idx_cond, ld_matrix = ld_matrix,\n                              hwe_diag = hwe_diag, hwe_diag_outside = hwe_diag_outside,data_set = data_set,\n                              all_but_one = F,colinear_threshold = 0.9)\n    res_step$Znew = res_step$beta_new/res_step$se_new\n    idx_top_tmp = which(max(abs(res_step$Znew),na.rm=T) == abs(res_step$Znew))\n    best_cond_row = res_step[idx_top_tmp,]\n    current_best_p = 2 * pnorm(abs(best_cond_row$Znew), lower.tail = F)\n    message(paste(\"Best SNP is = \", best_cond_row$rsid, \"with P-value \", current_best_p, \" Index = \", idx_top_tmp))\n    message(paste(\"Beta = \", best_cond_row$beta_new, \" Z = \",best_cond_row$Znew))\n    if(current_best_p < p_value_threshold){\n      best_cond_row$p = current_best_p\n      out_all_buts = rbind(out_all_buts,best_cond_row)\n    }\n  }\n  return(out_all_buts)\n}\n\n##' Step conditional\n##'\n##' Run a joint step of the analysis.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title step_conditional\n##' @param betas vector of betas that will be adjusted in the matrix operations.\n##' @param ld_matrix LD matrix for the subset of the region.\n##' @param neff effective sample size for each SNP in the dataset\n##' @param var_y variance of of the phenotype\n##' @param hwe_diag_outside Diagonal matrix containing the genotypic variance\n##' @param hwe_diag Diagonal matrix containing the genotypic variance *n\n##' @return Joint betas and standard errors.\n\nstep_conditional = function(betas, ld_matrix,neffs,var_y, hwe_diag_outside,hwe_diag){\n  inside =  ld_matrix\n  n_betas = length(betas)\n  outside = sqrt(diag(hwe_diag_outside)) %*% inside %*% sqrt(diag(hwe_diag_outside))\n  for(j in 1:ncol(outside)){\n    for(k in (j):ncol(outside)){\n      if(k > ncol(outside)){\n        break\n      }\n      outside[j,k] = min(neffs[c(j,k)]) *  outside[j,k]\n      if(k!=j){\n        outside[k,j] = min(neffs[c(j,k)]) * outside[k,j]\n      }\n    }\n  }\n  #print( sqrt(diag(hwe_diag)) %*% inside %*% sqrt(diag(hwe_diag)))\n  beta_inv = chol2inv(chol(outside))\n  #print(betas)\n  new_betas = beta_inv %*% diag(hwe_diag) %*% betas\n  #print(beta_inv)\n  # We only really care about the results from the first SNP\n  #because that's our SNP we are adding to the model\n  neff_var_y = neffs[1] * var_y\n  vars = (neff_var_y - t(betas) %*%  diag(hwe_diag) %*% ((betas))) / (neffs[1] - length(n_betas))\n  #print(vars)\n  ses = sqrt(diag(vars[1] * beta_inv))\n  #print(ses)\n  return(c(new_betas[1,1],ses[1]))\n}\n\n\nget_joint_betas = function(idx_joint,data_set,ld_matrix, hwe_diag,hwe_diag_outside, all_but_one=FALSE,colinear_threshold=.9){\n\n  res_step = data.frame(rsid=data_set$rsid,beta_old=data_set$b, beta_new=rep(NA,nrow(ld_matrix)),\n                      se_old=data_set$se, se_new=rep(NA,nrow(ld_matrix)))\n  for(j in 1:nrow(data_set)){\n    if(all_but_one){\n    if(j %in% idx_joint){\n      res_step$beta_new[j] = res_step$beta_old[j]\n      res_step$se_new[j] = res_step$se_old[j]\n      }\n    }else{\n      if(j %in% idx_joint){\n        message(\"Skipping SNP as already being conditioned on\")\n        next\n      }\n    }\n    of_interest = c(j, idx_joint)\n    betas = data_set$b[of_interest]\n    tmp_ld_matrix = ld_matrix[of_interest,of_interest]\n    neffs = data_set$neff[of_interest]\n    if(any(abs(tmp_ld_matrix[1,2:ncol(tmp_ld_matrix)]) > colinear_threshold)){\n      # message(\"Skipping SNP as co-linear with top_snps.\")\n      next\n    }\n    hwe_diag_outside_tmp = hwe_diag_outside[of_interest]\n    hwe_diag_tmp = hwe_diag[of_interest]\n    cond_results = step_conditional(betas, tmp_ld_matrix, neffs,var_y, hwe_diag_outside_tmp,hwe_diag_tmp)\n    res_step$beta_new[j]= cond_results[1]\n    res_step$se_new[j]= cond_results[2]\n  }\n  return(res_step)\n}\n\n##' All but one analysis\n##'\n##' Run the all but one analysis of the dataset.\n##'\n##'\n##' @author James Boocock\n##' @date 2 Aug 2016\n##' @title all_but_one\n##' @param data_set input file format\n##' @param ld_matrix LD matrix for the subset of the region.\n##' @param stepwise_results - results from a stepwise analysis.\n##' @return all_but_ones  betas and standard error for the entire region.\n##'\nall_but_one = function(res_preparation, stepwise_results,p_value_threshold=0.00001,colinear_threshold=0.9,var_y = 1.6421){\n  #extract variance from the dataset\n  hwe_diag = res_preparation$hwe_diag\n  data_set = res_preparation$data_set\n  hwe_diag_outside = res_preparation$hwe_diag_outside\n  ld_matrix = res_preparation$ld_matrix\n  idx_joint = which(data_set$rsid %in% stepwise_results$rsid)\n\n  if(length(idx_joint) == 0){\n    stop(\"No SNPs to perform an all but one conditional analysis on\")\n  }\n  if(length(idx_joint) == 1){\n   combinations=matrix(c(1))\n  }else{\n    combinations = combn(length(idx_joint),length(idx_joint) - 1)\n  }\n  message(paste(\"Runnnig the all but one conditional analysis for \",length(idx_joint),\" snps\"))\n  #message(paste(\"SNPs in model ... \"))\n  #message(as.character(data_set$rsid[idx_joint]), sep=\"\\n\")\n  all_but_one_res = list()\n  for(i in 1:ncol(combinations)){\n  #  idx_conditional = c(tmp_model_idx)\n    tmp_model_idx = idx_joint[combinations[,i]]\n    res_step= get_joint_betas(idx_joint = tmp_model_idx, ld_matrix = ld_matrix,\n                              hwe_diag = hwe_diag, hwe_diag_outside = hwe_diag_outside,data_set = data_set,\n                              all_but_one = T,colinear_threshold = 0.9)\n    hit = which(!(1:length(idx_joint) %in% combinations[,i]))\n    l1 =\n    all_but_one_res[[i]] = list(res_step=res_step, main_hit=as.character(data_set$rsid[idx_joint[hit]]),\n                                             conditional_on=c(as.character(data_set$rsid[idx_joint[combinations[,i]]])))\n  }\n  return(all_but_one_res)\n}\n",
    "created" : 1470175381766.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3797887711",
    "id" : "E0496C9E",
    "lastKnownWriteTime" : 1470286920,
    "last_content_update" : 1470286920109,
    "path" : "~/Sinai/corrcond/R/corrcond.R",
    "project_path" : "R/corrcond.R",
    "properties" : {
        "marks" : "<:252,19\n>:252,19",
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}